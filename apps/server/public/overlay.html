<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>maho overlay</title>
    <style>
      body {
        margin: 0;
        background: transparent;
        color: #fff;
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        overflow: hidden;
      }
      #wrap {
        padding: 16px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        height: 100vh;
        box-sizing: border-box;
      }

      .chat-line {
        margin: 4px 0;
        width: fit-content;
        max-width: 100%;
        display: block;
        opacity: 0;
        transform: translateY(10px);
        transition:
          opacity 0.4s ease,
          transform 0.4s ease;
        animation: enter 0.4s forwards;
      }

      @keyframes enter {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-line--exiting {
        opacity: 0;
        transform: translateY(-10px);
      }

      .chat-line--suppressed {
        opacity: 0.5;
        text-decoration: line-through;
      }

      .chat-line__header {
        display: inline;
        font-weight: 700;
        margin-right: 4px;
      }

      .chat-line__body {
        display: inline;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 8px;
        padding: 4px 8px;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .chat-line__author {
        color: #a970ff; /* fallback */
      }

      .chat-line__separator {
        margin-right: 4px;
      }

      .chat-line__badges {
        margin-right: 4px;
        display: inline-block;
        vertical-align: middle;
      }

      .chat-badge {
        display: inline-block;
        vertical-align: middle;
        height: 18px;
        margin-right: 2px;
        border-radius: 2px;
      }

      .chat-line__part-emote {
        height: 1.2em;
        vertical-align: middle;
        margin: 0 2px;
      }

      .chat-line__part-mention {
        font-weight: bold;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        padding: 0 4px;
      }

      .chat-line__part-link {
        color: #aaa;
        text-decoration: underline;
      }

      /* compatibility alias */
      .message-row {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="wrap"></div>
    <script>
      const wrap = document.getElementById("wrap");

      let styleTag = document.getElementById("maho-custom-css");
      if (!styleTag) {
        styleTag = document.createElement("style");
        styleTag.id = "maho-custom-css";
        document.head.appendChild(styleTag);
      }

      const wsProto = location.protocol === "https:" ? "wss:" : "ws:";
      const ws = new WebSocket(`${wsProto}//${location.host}/ws`);

      let lastRevision = -1;
      let config = {
        maxMessages: 10,
        lifetimeMs: 10000,
        fadeMs: 400,
        disappear: true,
        showNames: true,
        customCss: "",
      };

      class Queue {
        constructor() {
          this.items = [];
        }

        add(el) {
          wrap.appendChild(el);
          this.items.push({ el, ts: Date.now() });
          this.prune();
          this.scheduleExpiry(el);
        }

        prune() {
          while (this.items.length > config.maxMessages) {
            const item = this.items.shift();
            this.remove(item.el);
          }
        }

        scheduleExpiry(el) {
          if (!config.disappear) return;
          setTimeout(() => {
            if (document.body.contains(el)) this.remove(el);
          }, config.lifetimeMs);
        }

        remove(el) {
          if (el.classList.contains("chat-line--exiting")) return;
          el.classList.add("chat-line--exiting");
          el.style.transitionDuration = config.fadeMs + "ms";
          setTimeout(() => el.remove(), config.fadeMs);
        }

        reset() {
          this.items = [];
          wrap.innerHTML = "";
        }
      }

      const queue = new Queue();

      function renderPart(part) {
        if (part.type === "text") return document.createTextNode(part.content);

        if (part.type === "emote") {
          const img = document.createElement("img");
          if (part.url) {
            img.src = part.url;
          } else {
            img.src =
              "https://static-cdn.jtvnw.net/emoticons/v2/" +
              part.id +
              "/default/dark/1.0";
          }
          img.className = "chat-line__part-emote";
          img.alt = part.name;
          return img;
        }

        if (part.type === "mention") {
          const span = document.createElement("span");
          span.className = "chat-line__part-mention";
          span.textContent = "@" + part.user;
          return span;
        }

        if (part.type === "link") {
          const a = document.createElement("span");
          a.className = "chat-line__part-link";
          a.textContent = "[link]";
          return a;
        }
        return document.createTextNode("");
      }

      function applyEvent(payload) {
        const ev = payload.event;
        const actions = payload.actions || [];

        const div = document.createElement("div");
        div.className = "chat-line";
        div.classList.add("message-row"); // compatibility alias

        div.dataset.id = ev.id;
        div.dataset.platform = ev.platform;
        div.dataset.user = ev.user.login;
        if (ev.user.id) div.dataset.userId = ev.user.id;

        ev.user.roles.forEach((role) => {
          div.dataset["role" + role.charAt(0).toUpperCase() + role.slice(1)] =
            "true";
          div.classList.add("user-" + role);
        });

        actions.forEach((a) => {
          if (a.type === "suppress") div.classList.add("chat-line--suppressed");
          if (a.type === "addClass") div.classList.add(a.value);
          if (a.type === "setVar")
            div.style.setProperty("--" + a.name, a.value);
        });

        const header = document.createElement("div");
        header.className = "chat-line__header";

        if (config.showNames) {
          // badges
          const badgesContainer = document.createElement("span");
          badgesContainer.className = "chat-line__badges";

          if (ev.user.badges && ev.user.badges.length > 0) {
            ev.user.badges.forEach(b => {
              const img = document.createElement("img");
              img.className = "chat-badge";
              img.src = b.url;
              img.alt = b.title;
              img.title = b.title;
              img.classList.add("chat-badge--" + b.setId); 
              badgesContainer.appendChild(img);
            });
          }
          header.appendChild(badgesContainer);

          const name = document.createElement("span");
          name.className = "chat-line__author";
          name.textContent = ev.user.displayName;
          name.style.color = ev.user.color || "#a970ff";

          div.style.setProperty("--user-color", ev.user.color || "#a970ff");

          header.appendChild(name);

          const sep = document.createElement("span");
          sep.className = "chat-line__separator";
          sep.textContent = ": ";
          header.appendChild(sep);

          div.appendChild(header);
        }

        const body = document.createElement("div");
        body.className = "chat-line__body";

        if (ev.parts) {
          ev.parts.forEach((p) => body.appendChild(renderPart(p)));
        } else {
          body.textContent = ev.text;
        }

        div.appendChild(body);

        queue.add(div);
      }

      function updateConfig(newConfig) {
        config = { ...config, ...newConfig };
        queue.prune();
        if (typeof config.customCss === "string") {
          styleTag.textContent = config.customCss;
        }
      }

      ws.addEventListener("open", () => {
        ws.send(
          JSON.stringify({ op: "hello", role: "overlay", protocolVersion: 1 })
        );
      });

      ws.addEventListener("message", (e) => {
        const msg = JSON.parse(e.data);

        if (typeof msg.revision === "number") {
          if (msg.revision < lastRevision) return;
          lastRevision = msg.revision;
        }

        if (msg.op === "state" || msg.op === "config:changed") {
          if (msg.config) updateConfig(msg.config);
          return;
        }

        if (msg.op === "event") {
          applyEvent(msg.payload);
          return;
        }

        if (msg.op === "replay") {
          queue.reset();
          lastRevision = -1;

          msg.events.forEach((e) => {
            if (typeof e.revision === "number") {
              if (e.revision < lastRevision) return;
              lastRevision = e.revision;
            }
            applyEvent(e.payload);
          });

          queue.prune();
          return;
        }
      });
    </script>
  </body>
</html>
