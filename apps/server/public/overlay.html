<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>maho overlay</title>
    <style>
      :root {
        --user-color: #ffffff;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
      }

      body {
        margin: 0;
        background: transparent;
        color: #fff;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        font-size: 16px;
        line-height: 1.4;
        overflow: hidden;
      }

      #wrap {
        height: 100vh;
        padding: 16px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: flex-start;
        gap: 8px;
      }

      .item-row {
        position: relative;
        display: block;
        min-width: 0;
        max-width: 520px;
        padding: 0;
        margin: 0;

        opacity: 0;
        transform: translateY(10px);
        animation: maho-enter 0.3s ease-out forwards;

        overflow: visible;
      }

      @keyframes maho-enter {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .item-row--exiting {
        opacity: 0 !important;
        transform: translateX(-10px) !important;
        transition:
          opacity 0.4s ease,
          transform 0.4s ease;
        animation: none !important;
      }

      .chat-message__header {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .chat-message__badges {
        display: inline-flex;
        align-items: center;
        gap: 2px;
      }

      .chat-badge {
        display: block;
        height: 1em;
        width: auto;
      }

      .chat-message__author {
        font-weight: 700;
        color: var(--user-color);
      }

      .chat-message__body {
        word-break: break-word;
        overflow-wrap: anywhere;
      }

      .chat-message__part-emote {
        height: 1.3em;
        vertical-align: middle;
      }

      .event-alert__title {
        font-weight: 700;
      }

      .event-alert__message {
        font-weight: 700;
      }

      .event-alert__details {
        opacity: 0.85;
      }

      a {
        color: inherit;
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <div id="wrap"></div>

    <script>
      const wrap = document.getElementById("wrap");

      const ws = new WebSocket(
        `${location.protocol === "https:" ? "wss:" : "ws:"}//${location.host}/ws`
      );

      const styleTag = document.createElement("style");
      styleTag.id = "maho-custom-css";
      document.head.appendChild(styleTag);

      let lastEventSeq = -1;

      let sysConfig = { maxMessages: 50 };
      let theme = {
        values: {
          lifetimeMs: 30000,
          fadeMs: 400,
          disappear: true,
          showNames: true,
          customCss: "",
        },
      };

      class Queue {
        constructor() {
          this.items = [];
        }

        add(el) {
          wrap.appendChild(el);
          this.items.push({ el, ts: Date.now() });
          this.prune();
          this.scheduleExpiry(el);
        }

        prune() {
          while (this.items.length > (Number(sysConfig.maxMessages) || 50)) {
            const item = this.items.shift();
            this.remove(item.el);
          }
        }

        scheduleExpiry(el) {
          if (!theme.values.disappear) return;
          const ms = Number(theme.values.lifetimeMs) || 30000;
          setTimeout(() => {
            if (document.body.contains(el)) this.remove(el);
          }, ms);
        }

        remove(el) {
          if (!el || el.classList.contains("item-row--exiting")) return;

          const fade = Number(theme.values.fadeMs) || 400;
          el.classList.add("item-row--exiting");
          el.style.transitionDuration = fade + "ms";

          setTimeout(() => el.remove(), fade);
        }

        reset() {
          this.items = [];
          wrap.innerHTML = "";
        }
      }

      const queue = new Queue();

      function renderPart(p) {
        if (!p || typeof p !== "object") return document.createTextNode("");
        if (p.type === "text") return document.createTextNode(p.content ?? "");
        if (p.type === "emote") {
          const img = document.createElement("img");
          img.className = "chat-message__part-emote";
          img.src = p.url || `https://static-cdn.jtvnw.net/emoticons/v2/${p.id}/default/dark/1.0`;
          return img;
        }
        if (p.type === "mention") {
          const span = document.createElement("span");
          span.className = "chat-message__part-mention";
          span.textContent = "@" + p.user;
          return span;
        }
        if (p.type === "link") {
          const span = document.createElement("span");
          span.className = "chat-message__part-link";
          span.textContent = "[link]";
          return span;
        }
        return document.createTextNode("");
      }

      function applyThemePatch(patch) {
        if (!patch || typeof patch !== "object") return;
        if (!patch.values || typeof patch.values !== "object") return;

        theme.values = { ...theme.values, ...patch.values };

        if (typeof theme.values.customCss === "string") {
          styleTag.textContent = theme.values.customCss;
        }
      }

      function applyState(msg) {
        if (msg?.config?.data) sysConfig = msg.config.data;
        if (msg?.theme?.data) {
          // accept either {values:{...}} or raw theme object
          theme = msg.theme.data;
          if (!theme.values) theme.values = {};
          if (typeof theme.values.customCss === "string") {
            styleTag.textContent = theme.values.customCss;
          }
        }
      }

      function applyEvent(payload) {
        if (!payload || typeof payload !== "object") return;

        const ev = payload.event || {};
        const pres = payload.presentation || {};

        const actions = Array.isArray(payload.actions) ? payload.actions : [];
        const layers = Array.isArray(pres.layers) ? pres.layers : [];

        const isChat = pres.layout === "chat";

        const container = document.createElement(isChat ? "article" : "aside");
        container.className = `item-row ${isChat ? "chat-message" : "event-alert"}`;

        if (pres.styleHint) container.classList.add(`hint--${pres.styleHint}`);

        if (ev?.user?.color) {
          container.style.setProperty("--user-color", ev.user.color);
        }

        if (isChat && theme.values.showNames) {
          const header = document.createElement("header");
          header.className = "chat-message__header";

          const badges = Array.isArray(ev?.user?.badges) ? ev.user.badges : [];
          if (badges.length > 0) {
            const bCont = document.createElement("span");
            bCont.className = "chat-message__badges";

            for (const b of badges) {
              if (!b?.url) continue;
              const img = document.createElement("img");
              img.className = "chat-badge";
              img.src = b.url;
              img.alt = b.title || "";
              img.title = b.title || "";
              bCont.appendChild(img);
            }

            if (bCont.childNodes.length > 0) header.appendChild(bCont);
          }

          const name = document.createElement("span");
          name.className = "chat-message__author";
          name.textContent = ev?.user?.displayName ?? "Unknown";
          header.appendChild(name);

          container.appendChild(header);
        }

        // layer rendering
        for (const layer of layers) {
          if (!layer || typeof layer !== "object") continue;

          const prefix = isChat ? "chat-message" : "event-alert";
          const id = String(layer.id || "").trim();
          if (!id) continue;

          const parts = Array.isArray(layer.parts) ? layer.parts : [];
          if (parts.length === 0) continue;

          const el = document.createElement("div");
          el.className = `${prefix}__${id}`;

          for (const p of parts) el.appendChild(renderPart(p));

          if (el.textContent === "" && el.querySelector("img") == null)
            continue;

          container.appendChild(el);
        }

        // rules actions
        for (const a of actions) {
          if (!a || typeof a !== "object") continue;

          if (a.type === "addClass" && typeof a.value === "string") {
            container.classList.add(a.value);
          }
          if (a.type === "setVar" && typeof a.name === "string") {
            container.style.setProperty("--" + a.name, String(a.value ?? ""));
          }
        }

        queue.add(container);
      }

      ws.onopen = () => {
        ws.send(
          JSON.stringify({ op: "hello", role: "overlay", protocolVersion: 1 })
        );
      };

      ws.onmessage = (e) => {
        let msg;
        try {
          msg = JSON.parse(e.data);
        } catch {
          return;
        }

        if (msg.op === "state") {
          applyState(msg);
          return;
        }

        if (msg.op === "theme:changed") {
          applyThemePatch(msg.patch);
          return;
        }

        if (msg.op === "config:changed") {
          if (msg.patch && typeof msg.patch === "object") {
            sysConfig = { ...sysConfig, ...msg.patch };
            queue.prune();
          }
          return;
        }

        if (msg.op === "replay") {
          queue.reset();
          lastEventSeq = -1;
          const events = Array.isArray(msg.events) ? msg.events : [];
          for (const evt of events) {
            if (typeof evt.seq === "number" && evt.seq > lastEventSeq) {
              lastEventSeq = evt.seq;
              applyEvent(evt.payload);
            }
          }
          return;
        }

        if (msg.op === "event") {
          if (typeof msg.seq === "number" && msg.seq > lastEventSeq) {
            lastEventSeq = msg.seq;
            applyEvent(msg.payload);
          }
          return;
        }

        if (msg.op === "event:update") {
          const el = wrap.querySelector(`[data-id="${msg.id}"]`);
          if (!el) return;

          if (msg.patch.isDeleted) {
            const body = el.querySelector(".chat-message__body");
            if (body) {
              // TODO: send translated string from server
              el.classList.add("chat-message--suppressed");
              body.textContent = "<deleted>";
            }
          }
          return;
        }
      };
    </script>
  </body>
</html>
